---
title: 【笔记】你不知道的JS-上-2-词法作用域
date: 2025-06-27 15:01:29
tags: JS
---

《你不知道的 JavaScript》（上卷）第 2 章《词法作用域》深入探讨了 JavaScript 的作用域模型，重点解释了**词法作用域**的定义、特性及其与动态作用域的区别。以下是核心内容的总结：

---

### 1. **词法作用域的定义**

- **词法阶段决定作用域**：JavaScript 的作用域在代码**书写时**（即词法分析阶段）就已确定，由变量和函数声明的位置决定，而非运行时。
- **静态性**：作用域关系在代码编译阶段就已固定（与动态作用域对比）。

---

### 2. **作用域的工作模式**

- **作用域气泡（Scope Bubble）**：作用域可以看作逐层嵌套的气泡，内层作用域可以访问外层变量，反之则不行。
  ```javascript
  function foo() {
    var a = 2;
    function bar() {
      console.log(a); // 2（访问外层foo的作用域）
    }
    bar();
  }
  ```
- **遮蔽效应（Shadowing）**：内层作用域的同名标识符会遮蔽外层变量。
  ```javascript
  var a = 1;
  function foo() {
    var a = 2; // 遮蔽全局的a
    console.log(a); // 2
  }
  ```

---

### 3. **欺骗词法作用域（不推荐）**

- **`eval()`**：通过动态执行字符串代码修改词法作用域（严格模式下会创建独立作用域）。
  ```javascript
  function foo(str) {
    eval(str); // 欺骗！在foo内部插入变量b
    console.log(b); // 3
  }
  foo("var b = 3;");
  ```
- **`with`**：通过对象属性动态创建作用域（严格模式禁用，且会导致性能下降）。
  ```javascript
  var obj = { a: 1 };
  with (obj) {
    a = 2; // 修改obj.a
    b = 3; // 自动泄漏到全局（非严格模式）
  }
  ```
- **性能问题**：欺骗词法作用域会导致引擎无法在编译阶段优化作用域查找，降低代码执行效率。

---

### 4. **词法作用域 vs 动态作用域**

- **词法作用域**（JavaScript）：由代码结构静态决定，关注“函数声明的位置”。
- **动态作用域**（如 Bash）：由函数调用时的调用栈决定，关注“函数调用的位置”。
  ```javascript
  // 假设JavaScript是动态作用域（实际不是！）
  function foo() {
    console.log(a); // 动态作用域下会输出3（根据调用栈）
  }
  function bar() {
    var a = 3;
    foo();
  }
  var a = 2;
  bar(); // 词法作用域输出2，动态作用域会输出3
  ```

---

### 5. **关键结论**

- **词法作用域是 JavaScript 的基础**：变量查找规则由代码书写时的嵌套关系决定。
- **避免欺骗词法作用域**：`eval`和`with`会导致代码不可预测且性能下降。
- **理解遮蔽效应**：同名变量的覆盖规则是理解闭包和模块模式的前提。

---

这一章为后续学习**闭包**（第 3 章）奠定了基础，强调了 JavaScript 作用域的静态特性及其设计哲学。
