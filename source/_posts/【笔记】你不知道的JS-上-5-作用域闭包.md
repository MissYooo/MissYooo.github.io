---
title: 【笔记】你不知道的JS(上)-5.作用域闭包
date: 2025-06-29 20:23:28
tags: JS
---

第 5 章深入探讨了 JavaScript 中的**闭包（Closure）**机制，解释了闭包如何使函数“记住”并访问其词法作用域，即使该函数在其作用域外执行。

---

### **详细总结**

#### **1. 闭包的定义与核心概念**

- **定义**：闭包是指**函数能够访问并记住其词法作用域**，即使该函数在词法作用域之外执行。
- **本质**：函数持有对其定义时环境的引用，阻止作用域被垃圾回收。
- **示例**：
  ```javascript
  function outer() {
    var a = 2;
    function inner() {
      console.log(a); // 访问外部作用域的变量
    }
    return inner;
  }
  var fn = outer();
  fn(); // 2（闭包生效）
  ```

#### **2. 闭包的形成条件**

- **必要条件**：
  1. 函数嵌套（内部函数引用外部变量）。
  2. 内部函数在外部作用域中被调用（如通过返回值、事件回调等）。
- **常见场景**：
  - 返回函数（如模块模式）。
  - 异步回调（`setTimeout`、事件监听）。
  - 函数间接传递（如将函数作为参数传递）。

#### **3. 闭包的作用**

- **封装私有变量**：模拟模块化（ES6 之前的主流方案）。
  ```javascript
  function createCounter() {
    var count = 0;
    return {
      increment: function () {
        count++;
      },
      get: function () {
        return count;
      },
    };
  }
  var counter = createCounter();
  counter.increment();
  console.log(counter.get()); // 1
  ```
- **保持状态**：在异步或事件驱动编程中保留上下文。
  ```javascript
  for (var i = 1; i <= 5; i++) {
    (function (j) {
      setTimeout(function () {
        console.log(j); // 闭包保存每次循环的j值
      }, j * 1000);
    })(i);
  }
  ```

#### **4. 闭包与作用域链**

- **作用域链**：函数在定义时即确定其作用域链，闭包通过该链访问外部变量。
- **内存管理**：闭包可能导致外部作用域的变量无法释放，需谨慎使用（如清除无用的事件监听）。

#### **5. 闭包的现代应用**

- **替代方案**：ES6 的 `let` 块作用域可简化部分闭包场景（如循环问题）。
  ```javascript
  for (let i = 1; i <= 5; i++) {
    setTimeout(function () {
      console.log(i); // 块作用域直接解决
    }, i * 1000);
  }
  ```
- **模块系统**：ES6 Module 是闭包的官方实现，提供更清晰的封装。

#### **6. 性能与注意事项**

- **内存泄漏风险**：过度使用闭包可能导致长生命周期的变量无法回收。
- **优化建议**：
  - 避免不必要的闭包（如循环中创建大量函数）。
  - 显式解除引用（如 `fn = null`）。

---

### **关键结论**

- 闭包是 JavaScript 的核心特性，实现了**数据私有化**和**状态保持**。
- 理解闭包需要结合**作用域链**和**词法作用域**（第 3、4 章内容）。
- 现代开发中，`let/const` 和模块化可替代部分闭包场景，但闭包仍是高阶编程（如柯里化、惰性计算）的基础。

**关联章节**：

- 第 3 章（作用域）和第 4 章（提升）是闭包的理论基础。
